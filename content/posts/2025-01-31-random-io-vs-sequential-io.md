---
title: "랜덤 I/O vs 순차 I/O - 쿼리 성능의 핵심"
date: 2025-01-31
draft: false
tags: ["Database", "Performance", "Index", "SQL"]
summary: "인덱스가 항상 빠른 게 아닌 이유, 랜덤 I/O와 순차 I/O의 차이를 이해하면 쿼리 성능이 보인다."
---

## 물리적 디스크 관점에서 이해하기

HDD(하드디스크)를 떠올려보자.

```
순차 I/O: 디스크 헤드가 한 방향으로 쭉 읽음
[1][2][3][4][5] → 빠름

랜덤 I/O: 디스크 헤드가 여기저기 점프
[1]...[847]...[23]...[512] → 느림 (헤드 이동 시간 발생)
```

SSD에서도 랜덤 I/O가 순차보다 느리다. 정도의 차이일 뿐 원리는 동일하다.

## 데이터베이스 쿼리에서의 차이

### 순차 I/O가 발생하는 경우

**Full Table Scan**

```sql
SELECT * FROM orders WHERE status = 'pending'
```

테이블 전체를 처음부터 끝까지 읽는다. 데이터가 물리적으로 연속 저장되어 있어 대량 데이터 처리에 유리하다.

### 랜덤 I/O가 발생하는 경우

**인덱스를 통한 조회**

```sql
SELECT * FROM orders WHERE order_id = 12345
```

1. 인덱스에서 `order_id = 12345`의 위치(포인터)를 찾는다
2. 해당 포인터가 가리키는 실제 데이터 페이지로 점프한다
3. 이 "점프"가 랜덤 I/O다

## 왜 인덱스가 항상 좋은 건 아닌가?

100만 행 중 50만 행을 조회하는 상황을 생각해보자.

**인덱스 사용 시:**
- 50만 번의 랜덤 I/O 발생
- 디스크 헤드가 50만 번 점프

**Full Scan 시:**
- 순차적으로 100만 행 읽음
- 연속된 블록을 쭉 읽으므로 오히려 빠름

이래서 옵티마이저가 **선택도(Selectivity)**를 보고 판단한다.

| 선택도 | 반환 비율 | 옵티마이저 선택 |
|--------|----------|----------------|
| 높음 | ~5% 이하 | 인덱스 스캔 (랜덤 I/O) |
| 낮음 | ~20% 이상 | 풀 스캔 (순차 I/O) |

## 실무에서 자주 보는 패턴

### 커버링 인덱스 (랜덤 I/O 제거)

```sql
-- user_id, created_at을 포함하는 인덱스가 있다면
SELECT user_id, created_at FROM orders WHERE user_id = 100
```

인덱스 자체에 필요한 데이터가 다 있으면 테이블로 점프할 필요가 없다. 랜덤 I/O를 완전히 제거할 수 있다.

### 클러스터드 인덱스

```sql
-- MySQL InnoDB의 PRIMARY KEY
SELECT * FROM orders WHERE order_id BETWEEN 1000 AND 2000
```

PK 순서대로 데이터가 물리적으로 정렬되어 있어 **범위 조회가 순차 I/O**가 된다.

### 정렬이 필요한 쿼리

```sql
SELECT * FROM orders ORDER BY created_at DESC LIMIT 100
```

- `created_at` 인덱스 있음 → 인덱스 순서대로 읽음 (정렬 불필요)
- 인덱스 없음 → 전체 읽고 메모리에서 정렬 (filesort)

## 핵심 정리

| 구분 | 순차 I/O | 랜덤 I/O |
|------|----------|----------|
| 발생 상황 | 풀 스캔, 범위 스캔 | 인덱스 룩업 |
| 속도 | 빠름 | 느림 |
| 적합한 경우 | 대량 데이터 조회 | 소량 정확한 조회 |

> 인덱스는 "소수의 행을 빠르게 찾을 때" 효과적이다.
> 많은 행을 읽어야 한다면 순차 I/O가 오히려 유리하다.

쿼리 튜닝의 핵심은 "얼마나 많은 데이터를 읽어야 하는가"를 먼저 파악하는 것이다. 그래야 인덱스를 탈지, 풀 스캔이 나은지 판단할 수 있다.
